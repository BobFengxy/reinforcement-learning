#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Feb 22 15:56:36 2019

@author: fengxingyu
"""


fc_dim=256
f=20
m=5
lr= 0.05

def get_batch(data, labels, dataset_len, batch_size):
    random_order=random.sample(range(dataset_len), bastch_size)
    return data[random_oredre], labels[random_order]

 
def convnet(x):
 x=tf.layers.conv2d(x, filters=32, kernel_size=3, padding='SAME')
 x=tf.layers.max_pooling2d(x, pool_size=2, strides=2)
 x=tf.layers.conv2d(x, filters=64, kernel_size=3, padding='SAME')
 x=tf.layers.max_pooling2d(x, pool_size=2, strides=2)
 x=tf.layers.conv2d(x, filters=128, kernel_size=3, padding='SAME')
 x=tf.layers.max_pooling2d(x, pool_size=2, strides=2)
 return x


if __name__ == '__main__':
    act_mask=random.sample(range(0,f-1),m)
    mask_1=tf.zeros([f],tfk.int32)
    mask_2=tf.ones([m],tf.int32)
    ref = tf.Variable(mask_1,dtype = tf.int32)
    sess.run(tf.global_variables_initializer())
    # act_mask = sess.run(act_mask_1)#索引
    mask=tf.scatter_update(ref,indices=act_mask, updates=mask_2)#掩码
    #随机二维掩码 act_mask是索引 
    bool_1=sess.run(tf.cast(mask,bool))
    M=sess.run(tf.boolean_mask(F, bool_1))
    #产生M
    MF=tf.concat([M, F], 0)
    out=convnet(MF)
    fc1=tf.layers.dense(out, fc_dim)
    fc2=tf.layers.dense(mask, fc_dim)
    fc1_flatten=fc1.flatten()
    fc2_flatten=fc2.flatten()
    concat=tf.concat([fc1, fc2], 0)
    fc3=tf.layers.dense(concat, 3 * m)
    fc3_reshape=fc3.reshape(-1, 3)
    prob=tf.nn.softmax(fc3, 1)
    directions=tf.math.argmax(prob, 1)#此处是输出最大的索引，是一个向量[..,..,..,..]m个
    max_l= tf.reduce_max(prob,1)
    for i in range(m):#此处还需要添加移动的限制条件
        if directions[i]==0:
            if act_mask[i]!=0:
                act_mask[i]-=1
            else:
                act_mask[i]-=0
        if directions[i]==1:
            pass 
        if directions[i]==2:
            act_mask[i]+=1
    #生成了调整后的掩码act_mask,下一步生成新的M
    mask_3=tf.zeros([f],tf.int32)
    ref_1 = tf.Variable(mask_3,dtype = tf.int32)
    sess.run(tf.global_variables_initializer())
    mask_test_1=tf.scatter_update(ref=ref_1,indices=act_mask, updates=mask_2)
    mask_t = sess.run(mask_test_1)
    #新的掩码mask_t
    bool_2=sess.run(tf.cast(mask_t,bool))
    M_t=sess.run(tf.boolean_mask(F, bool_2))#新的M出现
    #此处输入LSTM，得出准确度P_t，与上一个P得出R
    R = 
    
    neg_log_prob = tf.reduce_sum(max_l)
    loss = tf.reduce_mean(-neg_log_prob * R)  # reward guided loss
    
    train_op = tf.train.AdamOptimizer(lr).minimize(loss)
